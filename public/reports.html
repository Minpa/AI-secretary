<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Secretary - ë¦¬í¬íŠ¸</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wordcloud2.js/1.2.2/wordcloud2.min.js"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Navigation -->
    <nav class="gradient-bg shadow-lg">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <a href="/" class="text-white text-xl font-bold">AI Secretary</a>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="/" class="text-white hover:text-gray-200 px-3 py-2 rounded-md">í™ˆ</a>
                    <a href="/dashboard" class="text-white hover:text-gray-200 px-3 py-2 rounded-md">ëŒ€ì‹œë³´ë“œ</a>
                    <a href="/test" class="text-white hover:text-gray-200 px-3 py-2 rounded-md">í…ŒìŠ¤íŠ¸</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-900">ìš´ì˜ ë¦¬í¬íŠ¸</h1>
            <p class="mt-2 text-gray-600">ì ‘ìˆ˜ í˜„í™© ë¶„ì„ ë° í†µê³„ ë¦¬í¬íŠ¸</p>
        </div>

        <!-- Filters -->
        <div class="bg-white shadow rounded-lg mb-8">
            <div class="px-6 py-4 border-b border-gray-200">
                <h2 class="text-lg font-medium text-gray-900">í•„í„° ì„¤ì •</h2>
            </div>
            <div class="px-6 py-4">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                    <!-- Date Range -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">ê¸°ê°„ ì„¤ì •</label>
                        <div class="space-y-2">
                            <input type="date" id="startDate" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                            <input type="date" id="endDate" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                        </div>
                    </div>

                    <!-- Channel Filter -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">ì ‘ìˆ˜ ì±„ë„</label>
                        <select id="channelFilter" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                            <option value="">ì „ì²´ ì±„ë„</option>
                            <option value="sms">ğŸ“± SMS</option>
                            <option value="email">ğŸ“§ ì´ë©”ì¼</option>
                            <option value="web">ğŸŒ ì›¹í¼</option>
                            <option value="call">ğŸ“ í†µí™”</option>
                        </select>
                    </div>

                    <!-- Status Filter -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">ì²˜ë¦¬ ìƒíƒœ</label>
                        <select id="statusFilter" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                            <option value="">ì „ì²´ ìƒíƒœ</option>
                            <option value="pending">ëŒ€ê¸°ì¤‘</option>
                            <option value="classified">ë¶„ë¥˜ì™„ë£Œ</option>
                            <option value="assigned">í• ë‹¹ë¨</option>
                            <option value="processed">ì²˜ë¦¬ì™„ë£Œ</option>
                        </select>
                    </div>

                    <!-- Priority Filter -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">ìš°ì„ ìˆœìœ„</label>
                        <select id="priorityFilter" class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm">
                            <option value="">ì „ì²´ ìš°ì„ ìˆœìœ„</option>
                            <option value="urgent">ê¸´ê¸‰</option>
                            <option value="high">ë†’ìŒ</option>
                            <option value="medium">ë³´í†µ</option>
                            <option value="low">ë‚®ìŒ</option>
                        </select>
                    </div>
                </div>
                <div class="mt-4 flex flex-wrap gap-2 items-center">
                    <button id="loadData" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 font-medium">
                        ğŸ”„ ìƒˆë¡œê³ ì¹¨
                    </button>
                    <span id="dataStatus" class="text-sm text-gray-500 hidden">
                        â³ ë°ì´í„° ë¡œë”© ì¤‘...
                    </span>
                    <button id="applyFilters" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">
                        í•„í„° ì ìš©
                    </button>
                    <button id="resetFilters" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700">
                        ì´ˆê¸°í™”
                    </button>
                    <button id="exportCSV" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">
                        CSV ë‚´ë³´ë‚´ê¸°
                    </button>
                    <button id="testWordCloud" class="bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700">
                        ğŸ”¤ ì›Œë“œí´ë¼ìš°ë“œ í…ŒìŠ¤íŠ¸
                    </button>
                    <button id="debugLibraries" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700">
                        ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒíƒœ í™•ì¸
                    </button>
                    <button id="testKeywords" class="bg-orange-600 text-white px-4 py-2 rounded-md hover:bg-orange-700">
                        ğŸ” í‚¤ì›Œë“œ í…ŒìŠ¤íŠ¸
                    </button>
                    <button id="testSections" class="bg-pink-600 text-white px-4 py-2 rounded-md hover:bg-pink-700">
                        ğŸ§ª ì„¹ì…˜ í…ŒìŠ¤íŠ¸
                    </button>
                    <button id="simpleTest" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">
                        âœ… ê°„ë‹¨ í…ŒìŠ¤íŠ¸
                    </button>
                    <button id="debugFilters" class="bg-yellow-600 text-white px-4 py-2 rounded-md hover:bg-yellow-700">
                        ğŸ” í•„í„° ë””ë²„ê·¸
                    </button>
                    <button id="debugFlow" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">
                        ğŸš¨ ì „ì²´ ë””ë²„ê·¸
                    </button>
                    <button id="fixTrendChart" class="bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700">
                        ğŸ”§ ì°¨íŠ¸ ê°•ì œ ìˆ˜ì •
                    </button>
                </div>
            </div>
        </div>

        <!-- Summary Statistics -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            <div class="bg-white overflow-hidden shadow rounded-lg">
                <div class="p-5">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <div class="w-8 h-8 bg-blue-500 rounded-md flex items-center justify-center">
                                <span class="text-white text-sm">ğŸ“¨</span>
                            </div>
                        </div>
                        <div class="ml-5 w-0 flex-1">
                            <dl>
                                <dt class="text-sm font-medium text-gray-500 truncate">ì´ ì ‘ìˆ˜</dt>
                                <dd class="text-lg font-medium text-gray-900" id="totalMessages">-</dd>
                            </dl>
                        </div>
                    </div>
                </div>
            </div>

            <div class="bg-white overflow-hidden shadow rounded-lg">
                <div class="p-5">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <div class="w-8 h-8 bg-green-500 rounded-md flex items-center justify-center">
                                <span class="text-white text-sm">âœ…</span>
                            </div>
                        </div>
                        <div class="ml-5 w-0 flex-1">
                            <dl>
                                <dt class="text-sm font-medium text-gray-500 truncate">ì²˜ë¦¬ì™„ë£Œ</dt>
                                <dd class="text-lg font-medium text-gray-900" id="processedMessages">-</dd>
                            </dl>
                        </div>
                    </div>
                </div>
            </div>

            <div class="bg-white overflow-hidden shadow rounded-lg">
                <div class="p-5">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <div class="w-8 h-8 bg-yellow-500 rounded-md flex items-center justify-center">
                                <span class="text-white text-sm">â³</span>
                            </div>
                        </div>
                        <div class="ml-5 w-0 flex-1">
                            <dl>
                                <dt class="text-sm font-medium text-gray-500 truncate">í‰ê·  ì²˜ë¦¬ì‹œê°„</dt>
                                <dd class="text-lg font-medium text-gray-900" id="avgProcessingTime">-</dd>
                            </dl>
                        </div>
                    </div>
                </div>
            </div>

            <div class="bg-white overflow-hidden shadow rounded-lg">
                <div class="p-5">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <div class="w-8 h-8 bg-red-500 rounded-md flex items-center justify-center">
                                <span class="text-white text-sm">ğŸ¯</span>
                            </div>
                        </div>
                        <div class="ml-5 w-0 flex-1">
                            <dl>
                                <dt class="text-sm font-medium text-gray-500 truncate">SLA ì¤€ìˆ˜ìœ¨</dt>
                                <dd class="text-lg font-medium text-gray-900" id="slaCompliance">-</dd>
                            </dl>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Word Cloud -->
        <div class="bg-white shadow rounded-lg mb-8">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 class="text-lg font-medium text-gray-900">ì£¼ìš” í‚¤ì›Œë“œ ë¶„ì„</h3>
                <p class="text-sm text-gray-500 mt-1">ì ‘ìˆ˜ëœ ìš”ì²­ì—ì„œ ê°€ì¥ ìì£¼ ì–¸ê¸‰ë˜ëŠ” í‚¤ì›Œë“œë“¤</p>
            </div>
            <div class="p-6">
                <div class="flex justify-center">
                    <canvas id="wordCloud" width="800" height="400" style="max-width: 100%; height: 400px;"></canvas>
                </div>
                <div class="mt-4 text-center">
                    <div id="wordCloudStats" class="text-sm text-gray-600"></div>
                </div>
            </div>
        </div>

        <!-- AI Insights -->
        <div class="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg mb-8">
            <div class="px-6 py-4 border-b border-blue-200">
                <h3 class="text-lg font-medium text-blue-900 flex items-center">
                    ğŸ¤– AI ì¸ì‚¬ì´íŠ¸
                    <span class="ml-2 text-sm font-normal text-blue-600">í‚¤ì›Œë“œ ë¶„ì„ ê¸°ë°˜ ìë™ ìƒì„±</span>
                </h3>
            </div>
            <div class="p-6">
                <div id="aiInsights" class="space-y-3">
                    <div class="text-center text-blue-600">í‚¤ì›Œë“œë¥¼ ë¶„ì„í•˜ì—¬ ì¸ì‚¬ì´íŠ¸ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘...</div>
                </div>
            </div>
        </div>

        <!-- Charts -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            <!-- Channel Distribution -->
            <div class="bg-white shadow rounded-lg">
                <div class="px-6 py-4 border-b border-gray-200">
                    <h3 class="text-lg font-medium text-gray-900">ì±„ë„ë³„ ì ‘ìˆ˜ í˜„í™©</h3>
                </div>
                <div class="p-6">
                    <canvas id="channelChart" width="400" height="300"></canvas>
                </div>
            </div>

            <!-- Status Distribution -->
            <div class="bg-white shadow rounded-lg">
                <div class="px-6 py-4 border-b border-gray-200">
                    <h3 class="text-lg font-medium text-gray-900">ìƒíƒœë³„ ë¶„í¬</h3>
                </div>
                <div class="p-6">
                    <canvas id="statusChart" width="400" height="300"></canvas>
                </div>
            </div>

            <!-- Priority Distribution -->
            <div class="bg-white shadow rounded-lg">
                <div class="px-6 py-4 border-b border-gray-200">
                    <h3 class="text-lg font-medium text-gray-900">ìš°ì„ ìˆœìœ„ë³„ ë¶„í¬</h3>
                </div>
                <div class="p-6">
                    <canvas id="priorityChart" width="400" height="300"></canvas>
                </div>
            </div>

            <!-- Daily Trend -->
            <div class="bg-white shadow rounded-lg">
                <div class="px-6 py-4 border-b border-gray-200">
                    <h3 class="text-lg font-medium text-gray-900">ì¼ë³„ ì ‘ìˆ˜ ì¶”ì´</h3>
                </div>
                <div class="p-6">
                    <canvas id="trendChart" width="400" height="300"></canvas>
                </div>
            </div>
        </div>

        <!-- Keyword Analysis -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            <!-- Top Keywords -->
            <div class="bg-white shadow rounded-lg">
                <div class="px-6 py-4 border-b border-gray-200">
                    <h3 class="text-lg font-medium text-gray-900">ìƒìœ„ í‚¤ì›Œë“œ ìˆœìœ„</h3>
                    <p class="text-sm text-gray-500 mt-1">ê°€ì¥ ìì£¼ ì–¸ê¸‰ë˜ëŠ” í‚¤ì›Œë“œ TOP 10</p>
                </div>
                <div class="p-6">
                    <div id="topKeywords" class="space-y-3">
                        <div class="text-center text-gray-500">ë°ì´í„°ë¥¼ ë¶„ì„í•˜ëŠ” ì¤‘...</div>
                    </div>
                </div>
            </div>

            <!-- Category Keywords -->
            <div class="bg-white shadow rounded-lg">
                <div class="px-6 py-4 border-b border-gray-200">
                    <h3 class="text-lg font-medium text-gray-900">ì¹´í…Œê³ ë¦¬ë³„ ì£¼ìš” í‚¤ì›Œë“œ</h3>
                    <p class="text-sm text-gray-500 mt-1">ë¶„ì•¼ë³„ ìì£¼ ì–¸ê¸‰ë˜ëŠ” í‚¤ì›Œë“œ</p>
                </div>
                <div class="p-6">
                    <div id="categoryKeywords" class="space-y-4">
                        <div class="text-center text-gray-500">ë°ì´í„°ë¥¼ ë¶„ì„í•˜ëŠ” ì¤‘...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Detailed Data Table -->
        <div class="bg-white shadow rounded-lg">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 class="text-lg font-medium text-gray-900">ìƒì„¸ ë°ì´í„°</h3>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ì ‘ìˆ˜ì¼ì‹œ</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ì±„ë„</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ë‚´ìš©</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ìš°ì„ ìˆœìœ„</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ìƒíƒœ</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ë¶„ë¥˜</th>
                        </tr>
                    </thead>
                    <tbody id="dataTable" class="bg-white divide-y divide-gray-200">
                        <tr>
                            <td colspan="6" class="px-6 py-4 text-center text-gray-500">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let currentData = [];
        let charts = {};
        let wordCloudInstance = null;

        // Wait for libraries to load
        function waitForLibraries() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max wait time
                
                const checkLibraries = () => {
                    attempts++;
                    const chartReady = typeof Chart !== 'undefined';
                    const wordCloudReady = typeof WordCloud !== 'undefined';
                    
                    console.log(`ğŸ“š Attempt ${attempts}: Chart.js available:`, chartReady, ', WordCloud available:', wordCloudReady);
                    
                    if (chartReady && wordCloudReady) {
                        console.log('âœ… All libraries loaded successfully');
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        console.log('â° Timeout waiting for libraries');
                        reject(new Error('Timeout waiting for libraries to load'));
                    } else {
                        setTimeout(checkLibraries, 100);
                    }
                };
                checkLibraries();
            });
        }

        // Initialize date inputs with default values
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ Reports page loaded');
            
            // Set default date range (last 7 days)
            const today = new Date();
            const lastWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            
            document.getElementById('startDate').value = lastWeek.toISOString().split('T')[0];
            document.getElementById('endDate').value = today.toISOString().split('T')[0];
            
            // Load data immediately without waiting for external libraries
            console.log('ğŸ“Š Auto-loading data on page load...');
            setTimeout(() => {
                loadReportData();
            }, 500); // Small delay to ensure DOM is fully ready
        });

        function showLoadingInSections() {
            // Show loading in keyword sections
            const topKeywordsDiv = document.getElementById('topKeywords');
            if (topKeywordsDiv) {
                topKeywordsDiv.innerHTML = '<div class="text-center text-blue-600 py-4">â³ í‚¤ì›Œë“œ ë¶„ì„ ì¤‘...</div>';
            }
            
            const categoryKeywordsDiv = document.getElementById('categoryKeywords');
            if (categoryKeywordsDiv) {
                categoryKeywordsDiv.innerHTML = '<div class="text-center text-blue-600 py-4">â³ ì¹´í…Œê³ ë¦¬ ë¶„ì„ ì¤‘...</div>';
            }
            
            // Show loading in trend chart (without destroying the canvas)
            const trendChart = document.getElementById('trendChart');
            if (trendChart) {
                // Hide the canvas and show loading message
                trendChart.style.display = 'none';
                
                // Add loading message if it doesn't exist
                let loadingDiv = trendChart.parentElement.querySelector('.trend-loading');
                if (!loadingDiv) {
                    loadingDiv = document.createElement('div');
                    loadingDiv.className = 'trend-loading text-center text-blue-600 py-8';
                    loadingDiv.textContent = 'â³ ì°¨íŠ¸ ìƒì„± ì¤‘...';
                    trendChart.parentElement.appendChild(loadingDiv);
                }
                loadingDiv.style.display = 'block';
            }
        }

        // Load report data
        async function loadReportData() {
            try {
                console.log('ğŸš€ Loading report data...');
                
                // Show loading status
                const statusEl = document.getElementById('dataStatus');
                if (statusEl) {
                    statusEl.textContent = 'â³ ë°ì´í„° ë¡œë”© ì¤‘...';
                    statusEl.className = 'text-sm text-blue-600';
                    statusEl.classList.remove('hidden');
                }
                
                // Show loading in sections
                showLoadingInSections();
                
                // Get filter values
                const filters = getFilterValues();
                console.log('ğŸ” Filters:', filters);
                
                // Load messages data (request more messages for better analysis)
                const messagesResponse = await fetch('/api/intake/messages?limit=1000');
                console.log('ğŸ“¡ Messages response status:', messagesResponse.status);
                
                const messagesData = await messagesResponse.json();
                console.log('ğŸ“Š Messages data:', messagesData);
                
                if (messagesData.success) {
                    currentData = messagesData.data;
                    console.log('âœ… Loaded', currentData.length, 'messages');
                    
                    // Apply filters
                    const filteredData = applyFilters(currentData, filters);
                    console.log('ğŸ” Filtered to', filteredData.length, 'messages');
                    
                    // Update statistics
                    try {
                        updateStatistics(filteredData);
                        console.log('âœ… Statistics updated');
                    } catch (error) {
                        console.error('âŒ Error updating statistics:', error);
                    }
                    
                    // Update charts
                    try {
                        updateCharts(filteredData);
                        console.log('âœ… Charts updated');
                    } catch (error) {
                        console.error('âŒ Error updating charts:', error);
                    }
                    
                    // Update word cloud
                    try {
                        updateWordCloud(filteredData);
                        console.log('âœ… Word cloud updated');
                    } catch (error) {
                        console.error('âŒ Error updating word cloud:', error);
                    }
                    
                    // Update table
                    try {
                        updateDataTable(filteredData);
                        console.log('âœ… Data table updated');
                    } catch (error) {
                        console.error('âŒ Error updating data table:', error);
                    }
                    
                    // Show success status
                    const statusEl = document.getElementById('dataStatus');
                    statusEl.textContent = `âœ… ${filteredData.length}ê°œ ë©”ì‹œì§€ ë¡œë“œ ì™„ë£Œ`;
                    statusEl.className = 'text-sm text-green-600';
                } else {
                    console.error('âŒ Failed to load messages:', messagesData);
                    const statusEl = document.getElementById('dataStatus');
                    statusEl.textContent = 'âŒ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨';
                    statusEl.className = 'text-sm text-red-600';
                }
                
                // Load SLA data
                const slaResponse = await fetch('/api/tickets/sla/dashboard');
                if (slaResponse.ok) {
                    const slaData = await slaResponse.json();
                    if (slaData.success) {
                        document.getElementById('slaCompliance').textContent = (slaData.data.slaPerformance || 0).toFixed(1) + '%';
                    }
                }
                
            } catch (error) {
                console.error('Error loading report data:', error);
                const statusEl = document.getElementById('dataStatus');
                statusEl.textContent = 'âŒ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ';
                statusEl.className = 'text-sm text-red-600';
            }
        }

        function getFilterValues() {
            return {
                startDate: document.getElementById('startDate').value,
                endDate: document.getElementById('endDate').value,
                channel: document.getElementById('channelFilter').value,
                status: document.getElementById('statusFilter').value,
                priority: document.getElementById('priorityFilter').value
            };
        }

        function applyFilters(data, filters) {
            return data.filter(item => {
                const itemDate = new Date(item.createdAt).toISOString().split('T')[0];
                
                // Date range filter
                if (filters.startDate && itemDate < filters.startDate) return false;
                if (filters.endDate && itemDate > filters.endDate) return false;
                
                // Channel filter
                if (filters.channel && item.channel !== filters.channel) return false;
                
                // Status filter
                if (filters.status && item.status !== filters.status) return false;
                
                // Priority filter
                if (filters.priority && item.priority !== filters.priority) return false;
                
                return true;
            });
        }

        function updateStatistics(data) {
            document.getElementById('totalMessages').textContent = data.length;
            
            const processedCount = data.filter(item => item.status === 'processed').length;
            document.getElementById('processedMessages').textContent = processedCount;
            
            // Calculate average processing time (placeholder)
            document.getElementById('avgProcessingTime').textContent = '2.5ì‹œê°„';
        }

        function updateCharts(data) {
            console.log('ğŸ“Š updateCharts called with', data.length, 'items');
            console.log('ğŸ“Š Chart.js available:', typeof Chart !== 'undefined');
            
            // Always try fallback charts first since they're more reliable
            console.log('ğŸ“Š Using fallback charts for reliability');
            try {
                updateFallbackCharts(data);
                console.log('âœ… All fallback charts updated');
            } catch (error) {
                console.error('âŒ Error in fallback charts:', error);
            }
        }
        
        function updateFallbackCharts(data) {
            console.log('ğŸ“Š updateFallbackCharts called with', data.length, 'items');
            
            try {
                console.log('ğŸ“Š Updating fallback channel chart...');
                updateFallbackChannelChart(data);
                
                console.log('ğŸ“Š Updating fallback status chart...');
                updateFallbackStatusChart(data);
                
                console.log('ğŸ“Š Updating fallback priority chart...');
                updateFallbackPriorityChart(data);
                
                console.log('ğŸ“Š Updating fallback trend chart...');
                updateFallbackTrendChart(data);
                
                console.log('âœ… All fallback charts completed');
            } catch (error) {
                console.error('âŒ Error in updateFallbackCharts:', error);
            }
        }
        
        function updateFallbackChannelChart(data) {
            const channelCounts = {};
            data.forEach(item => {
                channelCounts[item.channel] = (channelCounts[item.channel] || 0) + 1;
            });
            
            const canvas = document.getElementById('channelChart');
            const container = canvas.parentElement;
            
            // Replace canvas with HTML chart
            container.innerHTML = `
                <div class="space-y-3">
                    ${Object.entries(channelCounts).map(([channel, count]) => {
                        const percentage = (count / data.length * 100).toFixed(1);
                        const channelNames = { sms: 'SMS', email: 'ì´ë©”ì¼', web: 'ì›¹í¼', call: 'í†µí™”' };
                        const colors = { sms: 'bg-blue-500', email: 'bg-green-500', web: 'bg-yellow-500', call: 'bg-red-500' };
                        return `
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium">${channelNames[channel] || channel}</span>
                                <div class="flex items-center space-x-2">
                                    <div class="w-32 bg-gray-200 rounded-full h-2">
                                        <div class="${colors[channel] || 'bg-gray-500'} h-2 rounded-full" style="width: ${percentage}%"></div>
                                    </div>
                                    <span class="text-sm text-gray-600">${count}ê±´ (${percentage}%)</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function updateFallbackStatusChart(data) {
            const statusCounts = {};
            data.forEach(item => {
                statusCounts[item.status] = (statusCounts[item.status] || 0) + 1;
            });
            
            const canvas = document.getElementById('statusChart');
            const container = canvas.parentElement;
            const statusLabels = { pending: 'ëŒ€ê¸°ì¤‘', classified: 'ë¶„ë¥˜ì™„ë£Œ', assigned: 'í• ë‹¹ë¨', processed: 'ì²˜ë¦¬ì™„ë£Œ' };
            const statusColors = { pending: 'bg-gray-500', classified: 'bg-blue-500', assigned: 'bg-purple-500', processed: 'bg-green-500' };
            
            container.innerHTML = `
                <div class="space-y-3">
                    ${Object.entries(statusCounts).map(([status, count]) => {
                        const percentage = (count / data.length * 100).toFixed(1);
                        return `
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium">${statusLabels[status] || status}</span>
                                <div class="flex items-center space-x-2">
                                    <div class="w-32 bg-gray-200 rounded-full h-2">
                                        <div class="${statusColors[status] || 'bg-gray-500'} h-2 rounded-full" style="width: ${percentage}%"></div>
                                    </div>
                                    <span class="text-sm text-gray-600">${count}ê±´ (${percentage}%)</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function updateFallbackPriorityChart(data) {
            const priorityCounts = {};
            data.forEach(item => {
                priorityCounts[item.priority] = (priorityCounts[item.priority] || 0) + 1;
            });
            
            const canvas = document.getElementById('priorityChart');
            const container = canvas.parentElement;
            const priorityLabels = { urgent: 'ê¸´ê¸‰', high: 'ë†’ìŒ', medium: 'ë³´í†µ', low: 'ë‚®ìŒ' };
            const priorityColors = { urgent: 'bg-red-500', high: 'bg-orange-500', medium: 'bg-yellow-500', low: 'bg-green-500' };
            
            container.innerHTML = `
                <div class="space-y-3">
                    ${Object.entries(priorityCounts).map(([priority, count]) => {
                        const percentage = (count / data.length * 100).toFixed(1);
                        return `
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium">${priorityLabels[priority] || priority}</span>
                                <div class="flex items-center space-x-2">
                                    <div class="w-32 bg-gray-200 rounded-full h-2">
                                        <div class="${priorityColors[priority] || 'bg-gray-500'} h-2 rounded-full" style="width: ${percentage}%"></div>
                                    </div>
                                    <span class="text-sm text-gray-600">${count}ê±´ (${percentage}%)</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function updateFallbackTrendChart(data) {
            console.log('ğŸ“ˆ updateFallbackTrendChart called with', data.length, 'messages');
            
            try {
                // Find container by looking for the trend chart section title
                const trendSection = Array.from(document.querySelectorAll('h3')).find(h3 => 
                    h3.textContent.includes('ì¼ë³„ ì ‘ìˆ˜ ì¶”ì´')
                );
                
                if (!trendSection) {
                    console.error('âŒ Could not find trend chart section');
                    return;
                }
                
                // Find the container (should be the parent's next sibling with class p-6)
                const container = trendSection.parentElement.nextElementSibling;
                if (!container) {
                    console.error('âŒ trendChart container not found');
                    return;
                }
                
                console.log('âœ… Found trend chart container:', container);
                
                // FORCE CLEAR: Remove all content and start fresh
                container.innerHTML = '';
                console.log('ğŸ§¹ Cleared container completely');
                
                if (!data || data.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-500 py-8">ì„ íƒí•œ ê¸°ê°„ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.<br><small class="text-xs">ë‹¤ë¥¸ ë‚ ì§œ ë²”ìœ„ë¥¼ ì„ íƒí•´ë³´ì„¸ìš”.</small></div>';
                    console.log('ğŸ“ˆ No data - showing empty message');
                    return;
                }
                
                // Simple approach: count messages by date
                const dailyCounts = {};
                data.forEach(item => {
                    try {
                        const date = new Date(item.createdAt).toISOString().split('T')[0];
                        dailyCounts[date] = (dailyCounts[date] || 0) + 1;
                    } catch (e) {
                        console.warn('Invalid date:', item.createdAt);
                    }
                });
                
                console.log('ğŸ“ˆ Daily counts:', dailyCounts);
                
                // Get all dates and sort them
                const allDates = Object.keys(dailyCounts).sort();
                if (allDates.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-500 py-8">ë‚ ì§œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                    console.log('ğŸ“ˆ No valid dates found');
                    return;
                }
                
                // Show last 7 days or all available dates (whichever is more)
                let displayDates;
                if (allDates.length === 1) {
                    // Single day - show it with context
                    const singleDate = new Date(allDates[0]);
                    displayDates = [];
                    for (let i = -3; i <= 3; i++) {
                        const date = new Date(singleDate);
                        date.setDate(date.getDate() + i);
                        displayDates.push(date.toISOString().split('T')[0]);
                    }
                } else {
                    // Multiple days - use actual range
                    displayDates = allDates;
                }
                
                const maxCount = Math.max(...Object.values(dailyCounts));
                console.log('ğŸ“ˆ Display dates:', displayDates);
                console.log('ğŸ“ˆ Max count:', maxCount);
                
                // Generate HTML
                const chartHTML = displayDates.map(date => {
                    const count = dailyCounts[date] || 0;
                    const percentage = maxCount > 0 ? Math.max((count / maxCount * 100), count > 0 ? 5 : 0) : 0;
                    
                    let dateStr;
                    try {
                        dateStr = new Date(date).toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' });
                    } catch (e) {
                        dateStr = date;
                    }
                    
                    return `
                        <div class="flex items-center justify-between py-2">
                            <span class="text-sm font-medium text-gray-700">${dateStr}</span>
                            <div class="flex items-center space-x-3">
                                <div class="w-24 bg-gray-200 rounded-full h-3">
                                    <div class="bg-purple-500 h-3 rounded-full transition-all duration-300" style="width: ${percentage}%"></div>
                                </div>
                                <span class="text-sm text-gray-600 w-8 text-right">${count}ê±´</span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Create chart directly in container
                container.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; color: #6B7280; font-size: 12px; margin-bottom: 15px;">ì¼ë³„ ì ‘ìˆ˜ í˜„í™©</div>
                        ${chartHTML}
                    </div>
                `;
                
                console.log('ğŸ“ˆ Chart HTML created with', displayDates.length, 'dates');
                
                console.log('âœ… Trend chart updated successfully');
                
            } catch (error) {
                console.error('âŒ Error in updateFallbackTrendChart:', error);
                
                // Try to show error message in the trend chart section
                const trendSection = Array.from(document.querySelectorAll('h3')).find(h3 => 
                    h3.textContent.includes('ì¼ë³„ ì ‘ìˆ˜ ì¶”ì´')
                );
                
                if (trendSection) {
                    const container = trendSection.parentElement.nextElementSibling;
                    if (container) {
                        container.innerHTML = '<div class="text-center text-red-500 py-8">ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
                    }
                }
            }
        }

        function updateWordCloud(data) {
            console.log('ğŸ” Updating word cloud with data:', data.length, 'messages');
            
            // Extract keywords from content and classification categories
            const keywordFrequency = {};
            
            data.forEach(item => {
                // Add classification category as a keyword
                if (item.classification) {
                    const categoryNames = {
                        'billing': 'ê´€ë¦¬ë¹„',
                        'maintenance': 'ìˆ˜ë¦¬',
                        'parking': 'ì£¼ì°¨',
                        'noise': 'ì†ŒìŒ',
                        'inquiry': 'ë¬¸ì˜',
                        'complaint': 'ë¯¼ì›',
                        'facility': 'ì‹œì„¤',
                        'security': 'ë³´ì•ˆ'
                    };
                    const categoryKeyword = categoryNames[item.classification] || item.classification;
                    keywordFrequency[categoryKeyword] = (keywordFrequency[categoryKeyword] || 0) + 3; // Weight categories higher
                }
                
                // Extract meaningful Korean keywords from content
                const content = item.content || item.maskedContent; // Use original content for better keyword extraction
                const keywords = extractKoreanKeywords(content);
                keywords.forEach(keyword => {
                    keywordFrequency[keyword] = (keywordFrequency[keyword] || 0) + 1;
                });
            });
            
            console.log('ğŸ“Š Keyword frequency:', Object.keys(keywordFrequency).length, 'unique keywords');
            const topKeywords = Object.entries(keywordFrequency).sort((a, b) => b[1] - a[1]).slice(0, 10);
            console.log('ğŸ” Top keywords:', topKeywords);
            console.log('ğŸ” Top 5 keywords for consistency check:', topKeywords.slice(0, 5).map(([word, count]) => `${word}:${count}`).join(', '));
            
            // Convert to word cloud format with better filtering
            const meaninglessWords = new Set([
                'ë¬¸ì˜', 'ìš”ì²­', 'í™•ì¸', 'ë¶€íƒ', 'ë‹ˆë‹¤', 'ìŠµë‹ˆë‹¤', 'ì…ë‹ˆë‹¤', 'í•©ë‹ˆë‹¤', 'ë©ë‹ˆë‹¤',
                'í•´ì£¼ì„¸ìš”', 'ë¶€íƒë“œë ¤ìš”', 'ì‹¶ìŠµë‹ˆë‹¤', 'ìˆìŠµë‹ˆë‹¤', 'ë“œë¦½ë‹ˆë‹¤', 'ë“œë ¤ìš”', 'ë‚˜ìš”',
                'ì–´ìš”', 'ì•„ìš”', 'ë„¤ìš”', 'ì£ ', 'ê±°ì˜ˆìš”', 'ì´ì—ìš”', 'ì˜ˆìš”', 'í™•ì¸ë¶€íƒ', 'ë¶€íƒë“œë¦½'
            ]);
            
            const wordCloudData = Object.entries(keywordFrequency)
                .filter(([keyword, count]) => {
                    return count >= 1 && 
                           keyword.length >= 2 && 
                           !meaninglessWords.has(keyword) &&
                           !keyword.includes('ë‹ˆë‹¤') &&
                           !keyword.includes('ë¶€íƒ') &&
                           !keyword.includes('í™•ì¸') &&
                           !keyword.includes('ë¬¸ì˜') &&
                           !keyword.includes('ìš”ì²­') &&
                           !keyword.endsWith('ìš”') &&
                           !keyword.endsWith('ë„¤ìš”');
                })
                .sort((a, b) => b[1] - a[1]) // Sort by frequency
                .slice(0, 20) // Top 20 meaningful keywords
                .map(([keyword, count]) => [keyword, Math.max(count * 12, 10)]); // Scale for better visualization

            console.log('â˜ï¸ Word cloud data:', wordCloudData.length, 'keywords:', wordCloudData.slice(0, 10));

            // Clear previous word cloud
            const canvas = document.getElementById('wordCloud');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (wordCloudData.length === 0) {
                ctx.fillStyle = '#9CA3AF';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ë¶„ì„í•  ë°ì´í„°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤', canvas.width / 2, canvas.height / 2);
                console.log('âš ï¸ No word cloud data to display');
                return;
            }

            // Check if WordCloud is available
            if (typeof WordCloud === 'undefined') {
                console.error('âŒ WordCloud library not loaded');
                ctx.fillStyle = '#EF4444';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ì›Œë“œí´ë¼ìš°ë“œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë”© ì‹¤íŒ¨', canvas.width / 2, canvas.height / 2);
                return;
            }

            console.log('âœ… Generating word cloud...');
            
            // Generate word cloud
            try {
                // Create deterministic color mapping
                const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#06B6D4'];
                let colorIndex = 0;
                
                WordCloud(canvas, {
                    list: wordCloudData,
                    gridSize: Math.round(16 * canvas.width / 1024),
                    weightFactor: function (size) {
                        return Math.pow(size, 0.8) * canvas.width / 1024;
                    },
                    fontFamily: 'Noto Sans KR, Arial, sans-serif',
                    color: function (word, weight, fontSize, distance, theta) {
                        // Use deterministic color based on word hash
                        let hash = 0;
                        for (let i = 0; i < word.length; i++) {
                            hash = ((hash << 5) - hash + word.charCodeAt(i)) & 0xffffffff;
                        }
                        return colors[Math.abs(hash) % colors.length];
                    },
                    rotateRatio: 0.1, // Reduce rotation for more consistent layout
                    backgroundColor: '#FFFFFF',
                    minSize: 12,
                    drawOutOfBound: false,
                    shuffle: false, // Disable shuffling for consistent positioning
                    rotationSteps: 2 // Limit rotation steps for consistency
                });
                console.log('âœ… Word cloud generated successfully');
            } catch (error) {
                console.error('âŒ Error generating word cloud:', error);
                console.log('ğŸ”„ Falling back to simple text display');
                drawSimpleWordCloud(canvas, wordCloudData);
            }

            // Update stats
            const statsDiv = document.getElementById('wordCloudStats');
            const totalWords = Object.keys(keywordFrequency).length;
            const totalMentions = Object.values(keywordFrequency).reduce((sum, count) => sum + count, 0);
            const topWord = wordCloudData[0];
            
            statsDiv.innerHTML = `
                <div class="flex justify-center space-x-6 text-sm">
                    <span>ì´ í‚¤ì›Œë“œ: <strong>${totalWords}ê°œ</strong></span>
                    <span>ì´ ì–¸ê¸‰: <strong>${totalMentions}íšŒ</strong></span>
                    ${topWord ? `<span>ìµœë‹¤ ì–¸ê¸‰: <strong>"${topWord[0]}" (${Math.round(topWord[1]/10)}íšŒ)</strong></span>` : ''}
                </div>
            `;

            // Debug: Show sample of keyword frequency
            console.log('ğŸ” Sample keywords from frequency:', Object.entries(keywordFrequency).slice(0, 10));
            
            // Always update keyword sections (even with empty data)
            console.log('ğŸ” Updating top keywords with frequency data:', Object.keys(keywordFrequency).length, 'keywords');
            try {
                updateTopKeywords(keywordFrequency);
                console.log('âœ… Top keywords section updated');
            } catch (error) {
                console.error('âŒ Error updating top keywords:', error);
            }
            
            // Update category keywords section  
            console.log('ğŸ“Š Updating category keywords');
            try {
                updateCategoryKeywords(keywordFrequency);
                console.log('âœ… Category keywords section updated');
            } catch (error) {
                console.error('âŒ Error updating category keywords:', error);
            }
        }

        function extractKoreanKeywords(text) {
            // Extract meaningful Korean apartment management keywords
            const apartmentKeywords = [
                // Facilities
                'ì—˜ë¦¬ë² ì´í„°', 'ìŠ¹ê°•ê¸°', 'ì£¼ì°¨ì¥', 'ì£¼ì°¨', 'íƒë°°ë³´ê´€í•¨', 'íƒë°°í•¨', 'ìš°í¸í•¨', 
                'ê´€ë¦¬ì‚¬ë¬´ì†Œ', 'ê²½ë¹„ì‹¤', 'ë¡œë¹„', 'ë³µë„', 'ê³„ë‹¨', 'ì˜¥ìƒ', 'ì§€í•˜ì‹¤', 'ì°½ê³ ',
                
                // Utilities & Systems  
                'ë‚œë°©', 'ëƒ‰ë°©', 'ì—ì–´ì»¨', 'ë³´ì¼ëŸ¬', 'ì˜¨ìˆ˜', 'ëƒ‰ìˆ˜', 'ìˆ˜ë„', 'ì „ê¸°', 'ê°€ìŠ¤',
                'ì¸í„°ë„·', 'ì¼€ì´ë¸”', 'ì „í™”', 'ì¸í„°í°', 'ë°©ì†¡', 'ì¡°ëª…', 'í™˜ê¸°', 'ì •ì „', 'ë³µêµ¬',
                
                // Maintenance Issues
                'ê³ ì¥', 'ìˆ˜ë¦¬', 'ì ê²€', 'êµì²´', 'ì²­ì†Œ', 'ì •ë¹„', 'ë³´ìˆ˜', 'ëˆ„ìˆ˜', 'ë§‰í˜',
                'ì†ŒìŒ', 'ì§„ë™', 'ëƒ„ìƒˆ', 'ê³°íŒ¡ì´', 'ìŠµê¸°', 'ê· ì—´', 'íŒŒì†', 'ë°©ìŒ',
                
                // Services & Fees
                'ê´€ë¦¬ë¹„', 'ê³µê³¼ê¸ˆ', 'ìˆ˜ë„ìš”ê¸ˆ', 'ì „ê¸°ìš”ê¸ˆ', 'ê°€ìŠ¤ìš”ê¸ˆ', 'ì£¼ì°¨ë¹„', 'ì˜ìˆ˜ì¦', 'ì¬ë°œê¸‰',
                'ì²­ì†Œë¹„', 'ë³´ì•ˆë¹„', 'ìˆ˜ì„ ì¶©ë‹¹ê¸ˆ', 'ì¥ê¸°ìˆ˜ì„ ì¶©ë‹¹ê¸ˆ', 'í• ì¸', 'ìš”ê¸ˆ', 'ì›”ì •ì•¡',
                
                // Security & Safety
                'ë³´ì•ˆ', 'ë°©ë²”', 'CCTV', 'ì¶œì…', 'ì¶œì…ë¬¸', 'ë¹„ë°€ë²ˆí˜¸', 'ì¹´ë“œí‚¤', 
                'í™”ì¬', 'ì†Œë°©', 'ë¹„ìƒêµ¬', 'ì•ˆì „', 'ì‚¬ê³ ', 'ë„ë‚œ',
                
                // Community & Rules
                'ë¯¼ì›', 'ë¶„ë¦¬ìˆ˜ê±°', 'ì“°ë ˆê¸°', 'ì¬í™œìš©', 'ë°˜ë ¤ë™ë¬¼', 'ì• ì™„ë™ë¬¼',
                'í¡ì—°', 'ê¸ˆì—°', 'ì£¼ë¯¼', 'ì…ì£¼ë¯¼', 'ì´ì‚¬', 'ì…ì£¼', 'í‡´ê±°', 'ì»¤ë®¤ë‹ˆí‹°', 'í™œë™', 'ì°¸ì—¬',
                'ë¶ˆë²•ì£¼ì°¨', 'ê¸ˆì—°êµ¬ì—­', 'ì˜¨ë„ì¡°ì ˆ',
                
                // Common Issues (only meaningful ones)
                'ì‹ ê³ ', 'ë¶ˆë§Œ', 'ê°œì„ ', 'í•´ê²°', 'ì²˜ë¦¬', 'ì¡°ì¹˜', 'ëŒ€ì‘', 'ì•ˆë‚´', 'ê³µì§€', 'ì¶”ì²œ', 'ì—…ì²´'
            ];
            
            const foundKeywords = [];
            
            // Find exact matches for apartment keywords
            apartmentKeywords.forEach(keyword => {
                if (text.includes(keyword)) {
                    foundKeywords.push(keyword);
                }
            });
            
            // Extract compound Korean words (2-4 characters)
            const koreanWords = text.match(/[ê°€-í£]{2,4}/g) || [];
            const stopwords = new Set([
                // Polite expressions and common phrases
                'ë¬¸ì˜', 'ìš”ì²­', 'í™•ì¸', 'ë¶€íƒ', 'ë‹ˆë‹¤', 'ìŠµë‹ˆë‹¤', 'ì…ë‹ˆë‹¤', 'í•©ë‹ˆë‹¤', 'ë©ë‹ˆë‹¤', 
                'í•´ì£¼ì„¸ìš”', 'ë¶€íƒë“œë ¤ìš”', 'ê°ì‚¬í•©ë‹ˆë‹¤', 'ì•ˆë…•í•˜ì„¸ìš”', 'ì£„ì†¡í•©ë‹ˆë‹¤', 'ì‹¤ë¡€í•©ë‹ˆë‹¤',
                'í™•ì¸í•´ì£¼ì„¸ìš”', 'ì•Œë ¤ì£¼ì„¸ìš”', 'ë„ì™€ì£¼ì„¸ìš”', 'ë¶€íƒë“œë¦½ë‹ˆë‹¤', 'ì‹¶ìŠµë‹ˆë‹¤', 'ìˆìŠµë‹ˆë‹¤',
                
                // Question words and pronouns
                'ì–¸ì œ', 'ì–´ë””', 'ì–¼ë§ˆ', 'ì–´ë–»ê²Œ', 'ë¬´ì—‡', 'ëˆ„êµ¬', 'ì™œ', 'ì–´ëŠ', 'ëª‡ê°œ', 'ëª‡ëª…',
                'ì´ê²ƒ', 'ê·¸ê²ƒ', 'ì €ê²ƒ', 'ì—¬ê¸°', 'ê±°ê¸°', 'ì €ê¸°', 'ì´ê±°', 'ê·¸ê±°', 'ì €ê±°',
                
                // Particles and connectors
                'ë•Œë¬¸', 'ìœ„í•´', 'í†µí•´', 'ëŒ€í•´', 'ê´€í•´', 'ì—ì„œ', 'ì—ê²Œ', 'í•œí…Œ', 'ê»˜ì„œ', 'ì—ëŠ”',
                'ìœ¼ë¡œ', 'ë¡œì„œ', 'ë¶€í„°', 'ê¹Œì§€', 'ì²˜ëŸ¼', 'ê°™ì´', 'í•¨ê»˜', 'ê·¸ë¦¬ê³ ', 'ê·¸ëŸ°ë°',
                'í•˜ì§€ë§Œ', 'ê·¸ëŸ¬ë‚˜', 'ë˜í•œ', 'ê·¸ë˜ì„œ', 'ë”°ë¼ì„œ', 'ê·¸ëŸ¬ë©´', 'ë§Œì•½',
                
                // Common verbs and adjectives (endings)
                'ìˆë‚˜ìš”', 'ì—†ë‚˜ìš”', 'ë˜ë‚˜ìš”', 'í•˜ë‚˜ìš”', 'ì¸ê°€ìš”', 'ë‚˜ìš”', 'ì–´ìš”', 'ì•„ìš”', 'ë„¤ìš”',
                'ê±°ì˜ˆìš”', 'ì´ì—ìš”', 'ì˜ˆìš”', 'ì´ì•¼', 'ì•¼', 'ì§€ìš”', 'ì£ ', 'ê±°ë“ ìš”', 'ë“ ìš”',
                
                // Time and quantity words
                'ì§€ê¸ˆ', 'ì˜¤ëŠ˜', 'ë‚´ì¼', 'ì–´ì œ', 'ì´ë²ˆ', 'ë‹¤ìŒ', 'ì €ë²ˆ', 'ì˜¬í•´', 'ì‘ë…„', 'ë‚´ë…„',
                'ì•„ì¹¨', 'ì ì‹¬', 'ì €ë…', 'ë°¤', 'ìƒˆë²½', 'ì˜¤ì „', 'ì˜¤í›„', 'ì‹œê°„', 'ë¶„', 'ì´ˆ',
                'í•˜ë‚˜', 'ë‘˜', 'ì…‹', 'ë„·', 'ë‹¤ì„¯', 'ì—¬ì„¯', 'ì¼ê³±', 'ì—¬ëŸ', 'ì•„í™‰', 'ì—´',
                
                // Common apartment non-specific words
                'ìƒíƒœ', 'ë¬¸ì œ', 'ê²½ìš°', 'ë°©ë²•', 'ì´ìœ ', 'ê²°ê³¼', 'ê³¼ì •', 'ê³„íš', 'ì¤€ë¹„', 'ì™„ë£Œ',
                'ì‹œì‘', 'ë', 'ì¤‘ê°„', 'ì „ì²´', 'ë¶€ë¶„', 'ì¼ë¶€', 'ì „ë¶€', 'ëª¨ë“ ', 'ê°ê°', 'ì„œë¡œ',
                
                // Meaningless fragments
                'ë“œë ¤', 'ë“œë¦½', 'ë°›ì„', 'ë°›ëŠ”', 'ì£¼ëŠ”', 'í•˜ëŠ”', 'ë˜ëŠ”', 'ìˆëŠ”', 'ì—†ëŠ”', 'ê°™ì€',
                'ë‹¤ë¥¸', 'ìƒˆë¡œìš´', 'ì˜¤ë˜ëœ', 'ì¢‹ì€', 'ë‚˜ìœ', 'í°', 'ì‘ì€', 'ë§ì€', 'ì ì€'
            ]);
            
            koreanWords.forEach(word => {
                if (word.length >= 2 && 
                    !foundKeywords.includes(word) && 
                    !stopwords.has(word) &&
                    !/^[0-9]+$/.test(word) &&
                    !word.includes('ë‹ˆë‹¤') && // Filter out verb endings
                    !word.includes('ìŠµë‹ˆë‹¤') &&
                    !word.includes('ì…ë‹ˆë‹¤') &&
                    !word.includes('í•©ë‹ˆë‹¤') &&
                    !word.includes('ë¶€íƒ') &&
                    !word.includes('í™•ì¸') &&
                    !word.includes('ë¬¸ì˜') &&
                    !word.includes('ìš”ì²­') &&
                    !word.endsWith('ìš”') && // Filter out polite endings
                    !word.endsWith('ë„¤ìš”') &&
                    !word.endsWith('ì–´ìš”') &&
                    !word.endsWith('ì•„ìš”')) {
                    foundKeywords.push(word);
                }
            });
            
            return [...new Set(foundKeywords)]; // Remove duplicates
        }

        function analyzeWordFrequency(text) {
            console.log('ğŸ” Analyzing text of length:', text.length);
            
            // Korean text processing
            const frequency = {};
            
            // Remove special characters and normalize
            const cleanText = text
                .replace(/[^\w\sê°€-í£]/g, ' ')
                .replace(/\s+/g, ' ')
                .toLowerCase()
                .trim();

            console.log('ğŸ§¹ Clean text length:', cleanText.length);

            // Split into words
            const words = cleanText.split(' ');
            console.log('ğŸ“ Total words:', words.length);
            
            // Korean stopwords and common words to filter out
            const stopwords = new Set([
                'ì´', 'ê·¸', 'ì €', 'ê²ƒ', 'ìˆ˜', 'ìˆ', 'ì—†', 'í•˜', 'ë˜', 'ëœ', 'ë ', 'ëŠ”', 'ì€', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 
                'ì—', 'ì—ì„œ', 'ë¡œ', 'ìœ¼ë¡œ', 'ì™€', 'ê³¼', 'ë„', 'ë§Œ', 'ê¹Œì§€', 'ë¶€í„°', 'ë³´ë‹¤', 'ì²˜ëŸ¼', 'ê°™ì´', 'í•¨ê»˜',
                'ê·¸ë¦¬ê³ ', 'ê·¸ëŸ°ë°', 'í•˜ì§€ë§Œ', 'ê·¸ëŸ¬ë‚˜', 'ë˜í•œ', 'ë˜', 'ë°', 'ë“±', 'ì¦‰', 'ì˜ˆë¥¼ë“¤ì–´',
                'ìˆìŠµë‹ˆë‹¤', 'ìŠµë‹ˆë‹¤', 'ì…ë‹ˆë‹¤', 'í•©ë‹ˆë‹¤', 'ë©ë‹ˆë‹¤', 'ë‹ˆë‹¤', 'ì„¸ìš”', 'ìš”', 'ë„¤ìš”', 'ì–´ìš”',
                'ë•Œë¬¸', 'ìœ„í•´', 'í†µí•´', 'ëŒ€í•´', 'ê´€í•´', 'ë”°ë¼', 'ì˜í•´', 'ì—ê²Œ', 'í•œí…Œ', 'ê»˜', 'ì—ì„œ',
                'ë…„', 'ì›”', 'ì¼', 'ì‹œ', 'ë¶„', 'ì´ˆ', 'ì˜¤ì „', 'ì˜¤í›„', 'ì•„ì¹¨', 'ì ì‹¬', 'ì €ë…', 'ë°¤',
                'ì¸µ', 'í˜¸', 'ë™', 'ë²ˆ', 'ê°œ', 'ëª…', 'ë¶„', 'ì‹œê°„', 'ë‚ ', 'ì£¼', 'ë‹¬',
                'ì•ˆë…•í•˜ì„¸ìš”', 'ê°ì‚¬í•©ë‹ˆë‹¤', 'ì£„ì†¡í•©ë‹ˆë‹¤', 'ì‹¤ë¡€í•©ë‹ˆë‹¤', 'ë¶€íƒë“œë¦½ë‹ˆë‹¤', 'í™•ì¸', 'ë¬¸ì˜', 'ì‹ ê³ '
            ]);

            // Count word frequency
            words.forEach(word => {
                if (word.length >= 2 && !stopwords.has(word) && !/^\d+$/.test(word)) {
                    frequency[word] = (frequency[word] || 0) + 1;
                }
            });

            // Filter out very rare words (appear only once) unless they're important keywords
            const importantKeywords = new Set([
                'ì—˜ë¦¬ë² ì´í„°', 'ì£¼ì°¨', 'ì†ŒìŒ', 'ê´€ë¦¬ë¹„', 'ë³´ì•ˆ', 'ì¶œì…', 'í™”ì¬', 'ê°€ìŠ¤', 'ëˆ„ìˆ˜', 'ê³ ì¥', 'ìˆ˜ë¦¬',
                'ì²­ì†Œ', 'ì“°ë ˆê¸°', 'ë¶„ë¦¬ìˆ˜ê±°', 'íƒë°°', 'ë°©ë¬¸', 'ê³µì‚¬', 'ì‹œì„¤', 'ì „ê¸°', 'ìˆ˜ë„', 'ë‚œë°©',
                'ì—ì–´ì»¨', 'ì¸í„°ë„·', 'ì „í™”', 'ë„ì–´ë½', 'cctv', 'ë°©ë²”', 'ìˆœì°°', 'ë¯¼ì›', 'ë¶ˆë§Œ', 'ê°œì„ '
            ]);

            const filteredFrequency = {};
            Object.entries(frequency).forEach(([word, count]) => {
                if (count > 1 || importantKeywords.has(word)) {
                    filteredFrequency[word] = count;
                }
            });

            return filteredFrequency;
        }

        function drawSimpleWordCloud(canvas, wordCloudData) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            ctx.fillStyle = '#F9FAFB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#06B6D4'];
            let currentY = 50;
            let currentX = 50;
            const maxWidth = canvas.width - 100;
            
            // Sort wordCloudData by word for consistent positioning
            const sortedWordCloudData = [...wordCloudData].sort((a, b) => a[0].localeCompare(b[0]));
            
            sortedWordCloudData.forEach(([word, size], index) => {
                const fontSize = Math.max(12, Math.min(48, size / 10));
                ctx.font = `${fontSize}px Noto Sans KR, Arial, sans-serif`;
                // Use deterministic color based on word
                let hash = 0;
                for (let i = 0; i < word.length; i++) {
                    hash = ((hash << 5) - hash + word.charCodeAt(i)) & 0xffffffff;
                }
                ctx.fillStyle = colors[Math.abs(hash) % colors.length];
                
                const textWidth = ctx.measureText(word).width;
                
                // Check if word fits on current line
                if (currentX + textWidth > maxWidth) {
                    currentX = 50;
                    currentY += fontSize + 10;
                }
                
                // Don't draw if we're out of canvas bounds
                if (currentY > canvas.height - 50) return;
                
                ctx.fillText(word, currentX, currentY);
                currentX += textWidth + 20;
            });
            
            // Add title
            ctx.font = '16px Arial';
            ctx.fillStyle = '#6B7280';
            ctx.textAlign = 'center';
            ctx.fillText('ì£¼ìš” í‚¤ì›Œë“œ (ê°„ë‹¨ í‘œì‹œ)', centerX, 25);
            ctx.textAlign = 'left';
        }

        function updateTopKeywords(wordFrequency) {
            const topKeywordsDiv = document.getElementById('topKeywords');
            console.log('ğŸ” updateTopKeywords called with:', Object.keys(wordFrequency).length, 'keywords');
            
            // Apply the same filtering as word cloud
            const meaninglessWords = new Set([
                'ë¬¸ì˜', 'ìš”ì²­', 'í™•ì¸', 'ë¶€íƒ', 'ë‹ˆë‹¤', 'ìŠµë‹ˆë‹¤', 'ì…ë‹ˆë‹¤', 'í•©ë‹ˆë‹¤', 'ë©ë‹ˆë‹¤',
                'í•´ì£¼ì„¸ìš”', 'ë¶€íƒë“œë ¤ìš”', 'ì‹¶ìŠµë‹ˆë‹¤', 'ìˆìŠµë‹ˆë‹¤', 'ë“œë¦½ë‹ˆë‹¤', 'ë“œë ¤ìš”', 'ë‚˜ìš”',
                'ì–´ìš”', 'ì•„ìš”', 'ë„¤ìš”', 'ì£ ', 'ê±°ì˜ˆìš”', 'ì´ì—ìš”', 'ì˜ˆìš”', 'í™•ì¸ë¶€íƒ', 'ë¶€íƒë“œë¦½'
            ]);
            
            const sortedKeywords = Object.entries(wordFrequency)
                .filter(([keyword, count]) => {
                    return count >= 1 && 
                           keyword.length >= 2 && 
                           !meaninglessWords.has(keyword) &&
                           !keyword.includes('ë‹ˆë‹¤') &&
                           !keyword.includes('ë¶€íƒ') &&
                           !keyword.includes('í™•ì¸') &&
                           !keyword.includes('ë¬¸ì˜') &&
                           !keyword.includes('ìš”ì²­') &&
                           !keyword.endsWith('ìš”') &&
                           !keyword.endsWith('ë„¤ìš”');
                })
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
                
            console.log('ğŸ” Filtered keywords for top list:', sortedKeywords.length);

            if (sortedKeywords.length === 0) {
                const totalKeywords = Object.keys(wordFrequency).length;
                const message = totalKeywords === 0 
                    ? 'ì„ íƒí•œ ê¸°ê°„ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë‚ ì§œ ë²”ìœ„ë¥¼ ì„ íƒí•´ë³´ì„¸ìš”.' 
                    : 'ì˜ë¯¸ìˆëŠ” í‚¤ì›Œë“œê°€ ì—†ìŠµë‹ˆë‹¤. (ì¼ë°˜ì ì¸ í‘œí˜„ë§Œ ë°œê²¬ë¨)';
                topKeywordsDiv.innerHTML = `<div class="text-center text-gray-500 py-4">${message}</div>`;
                return;
            }

            const maxCount = sortedKeywords[0][1];
            
            topKeywordsDiv.innerHTML = sortedKeywords.map(([keyword, count], index) => {
                const percentage = (count / maxCount) * 100;
                
                return `
                    <div class="flex items-center justify-between p-3 border rounded-lg hover:bg-gray-50 transition-colors">
                        <div class="flex items-center space-x-3">
                            <div class="flex-shrink-0 w-8 h-8 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center text-sm font-bold">
                                ${index + 1}
                            </div>
                            <div>
                                <div class="font-medium text-gray-900">${keyword}</div>
                                <div class="text-sm text-gray-500">${count}íšŒ ì–¸ê¸‰</div>
                            </div>
                        </div>
                        <div class="flex-shrink-0 w-20">
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div class="bg-indigo-500 h-2 rounded-full transition-all duration-500" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

        }

        function updateCategoryKeywords(wordFrequency) {
            const categoryKeywordsDiv = document.getElementById('categoryKeywords');
            console.log('ğŸ“Š updateCategoryKeywords called with:', Object.keys(wordFrequency).length, 'keywords');
            
            // Define keyword categories
            const categories = {
                'ì‹œì„¤ê´€ë¦¬': ['ì—˜ë¦¬ë² ì´í„°', 'ê³ ì¥', 'ìˆ˜ë¦¬', 'ì „ê¸°', 'ìˆ˜ë„', 'ë‚œë°©', 'ì—ì–´ì»¨', 'ì‹œì„¤', 'ê³µì‚¬', 'ì²­ì†Œ'],
                'ì†ŒìŒ': ['ì†ŒìŒ', 'ì‹œë„', 'ì¸µê°„ì†ŒìŒ', 'ìœ—ì§‘', 'ì•„ë˜ì§‘', 'ë°¤', 'ìƒˆë²½', 'ìŒì•…', 'ë°œì†Œë¦¬'],
                'ì£¼ì°¨': ['ì£¼ì°¨', 'ì°¨ëŸ‰', 'ì£¼ì°¨ì¥', 'ì£¼ì°¨ìœ„ë°˜', 'ë¶ˆë²•ì£¼ì°¨', 'ì£¼ì°¨ê³µê°„', 'ìë™ì°¨', 'ì˜¤í† ë°”ì´'],
                'ê´€ë¦¬ë¹„': ['ê´€ë¦¬ë¹„', 'ìš”ê¸ˆ', 'ì²­êµ¬ì„œ', 'ë‚©ë¶€', 'ì—°ì²´', 'í• ì¸', 'ìš”ê¸ˆí‘œ', 'ê³„ì‚°ì„œ'],
                'ë³´ì•ˆ': ['ë³´ì•ˆ', 'ì¶œì…', 'ë„ì–´ë½', 'í‚¤', 'ë¶„ì‹¤', 'cctv', 'ë°©ë²”', 'ìˆœì°°', 'ì•ˆì „'],
                'ìƒí™œí¸ì˜': ['íƒë°°', 'ë°©ë¬¸', 'ì“°ë ˆê¸°', 'ë¶„ë¦¬ìˆ˜ê±°', 'ì¸í„°ë„·', 'ì „í™”', 'ë°©ì†¡', 'ê³µì§€']
            };

            const categoryStats = {};
            
            // Calculate category statistics
            Object.entries(categories).forEach(([category, keywords]) => {
                let totalCount = 0;
                const foundKeywords = [];
                
                keywords.forEach(keyword => {
                    if (wordFrequency[keyword]) {
                        totalCount += wordFrequency[keyword];
                        foundKeywords.push({ keyword, count: wordFrequency[keyword] });
                    }
                });
                
                if (totalCount > 0) {
                    categoryStats[category] = {
                        totalCount,
                        keywords: foundKeywords.sort((a, b) => b.count - a.count).slice(0, 3)
                    };
                    console.log(`ğŸ“Š Category ${category}: ${totalCount} total, keywords:`, foundKeywords.map(k => k.keyword));
                }
            });

            if (Object.keys(categoryStats).length === 0) {
                const totalKeywords = Object.keys(wordFrequency).length;
                const message = totalKeywords === 0 
                    ? 'ì„ íƒí•œ ê¸°ê°„ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë‚ ì§œ ë²”ìœ„ë¥¼ ì„ íƒí•´ë³´ì„¸ìš”.' 
                    : 'ì•„íŒŒíŠ¸ ê´€ë¦¬ ê´€ë ¨ í‚¤ì›Œë“œê°€ ì—†ìŠµë‹ˆë‹¤.';
                categoryKeywordsDiv.innerHTML = `<div class="text-center text-gray-500 py-4">${message}</div>`;
                return;
            }

            const maxCategoryCount = Math.max(...Object.values(categoryStats).map(cat => cat.totalCount));

            categoryKeywordsDiv.innerHTML = Object.entries(categoryStats)
                .sort((a, b) => b[1].totalCount - a[1].totalCount)
                .map(([category, stats]) => {
                    const percentage = (stats.totalCount / maxCategoryCount) * 100;
                    const categoryColors = {
                        'ì‹œì„¤ê´€ë¦¬': 'bg-blue-500',
                        'ì†ŒìŒ': 'bg-red-500',
                        'ì£¼ì°¨': 'bg-yellow-500',
                        'ê´€ë¦¬ë¹„': 'bg-green-500',
                        'ë³´ì•ˆ': 'bg-purple-500',
                        'ìƒí™œí¸ì˜': 'bg-indigo-500'
                    };
                    const color = categoryColors[category] || 'bg-gray-500';
                    
                    return `
                        <div class="border rounded-lg p-4 hover:shadow-md transition-shadow">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="font-medium text-gray-900">${category}</h4>
                                <span class="text-sm text-gray-500">${stats.totalCount}íšŒ</span>
                            </div>
                            <div class="mb-3">
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div class="${color} h-2 rounded-full transition-all duration-500" style="width: ${percentage}%"></div>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-2">
                                ${stats.keywords.map(({ keyword, count }) => `
                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                                        ${keyword} (${count})
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
        }

        function generateAIInsights(wordFrequency, data) {
            const insightsDiv = document.getElementById('aiInsights');
            const insights = [];

            // Analyze top issues
            const topKeywords = Object.entries(wordFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            if (topKeywords.length > 0) {
                const topIssue = topKeywords[0];
                insights.push({
                    icon: 'ğŸ”',
                    title: 'ì£¼ìš” ì´ìŠˆ ë¶„ì„',
                    content: `"${topIssue[0]}"ê°€ ${topIssue[1]}íšŒë¡œ ê°€ì¥ ë§ì´ ì–¸ê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ë¶„ì•¼ì— ëŒ€í•œ ì§‘ì¤‘ì ì¸ ê´€ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.`
                });
            }

            // Analyze urgency patterns
            const urgentCount = data.filter(item => item.priority === 'urgent').length;
            const highCount = data.filter(item => item.priority === 'high').length;
            const totalCount = data.length;

            if (totalCount > 0) {
                const urgencyRate = ((urgentCount + highCount) / totalCount * 100).toFixed(1);
                if (urgencyRate > 50) {
                    insights.push({
                        icon: 'âš ï¸',
                        title: 'ê¸´ê¸‰ë„ ë¶„ì„',
                        content: `ì „ì²´ ìš”ì²­ì˜ ${urgencyRate}%ê°€ ë†’ì€ ìš°ì„ ìˆœìœ„ì…ë‹ˆë‹¤. ì‹ ì†í•œ ëŒ€ì‘ ì²´ê³„ ê°•í™”ê°€ í•„ìš”í•©ë‹ˆë‹¤.`
                    });
                } else {
                    insights.push({
                        icon: 'âœ…',
                        title: 'ê¸´ê¸‰ë„ ë¶„ì„',
                        content: `ì „ì²´ ìš”ì²­ì˜ ${urgencyRate}%ê°€ ë†’ì€ ìš°ì„ ìˆœìœ„ë¡œ ì ì • ìˆ˜ì¤€ì…ë‹ˆë‹¤.`
                    });
                }
            }

            // Analyze channel patterns
            const channelCounts = {};
            data.forEach(item => {
                channelCounts[item.channel] = (channelCounts[item.channel] || 0) + 1;
            });

            const topChannel = Object.entries(channelCounts)
                .sort((a, b) => b[1] - a[1])[0];

            if (topChannel) {
                const channelNames = { sms: 'SMS', email: 'ì´ë©”ì¼', web: 'ì›¹í¼', call: 'í†µí™”' };
                insights.push({
                    icon: 'ğŸ“Š',
                    title: 'ì±„ë„ ë¶„ì„',
                    content: `${channelNames[topChannel[0]] || topChannel[0]}ë¥¼ í†µí•œ ì ‘ìˆ˜ê°€ ${topChannel[1]}ê±´ìœ¼ë¡œ ê°€ì¥ ë§ìŠµë‹ˆë‹¤. ì´ ì±„ë„ì˜ ì‚¬ìš©ì„± ê°œì„ ì„ ê³ ë ¤í•´ë³´ì„¸ìš”.`
                });
            }

            // Analyze processing efficiency
            const processedCount = data.filter(item => item.status === 'processed').length;
            const processingRate = totalCount > 0 ? (processedCount / totalCount * 100).toFixed(1) : 0;

            if (processingRate < 30) {
                insights.push({
                    icon: 'ğŸ“ˆ',
                    title: 'ì²˜ë¦¬ íš¨ìœ¨ì„±',
                    content: `ì²˜ë¦¬ ì™„ë£Œìœ¨ì´ ${processingRate}%ë¡œ ë‚®ìŠµë‹ˆë‹¤. ì—…ë¬´ í”„ë¡œì„¸ìŠ¤ ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.`
                });
            } else if (processingRate > 80) {
                insights.push({
                    icon: 'ğŸ¯',
                    title: 'ì²˜ë¦¬ íš¨ìœ¨ì„±',
                    content: `ì²˜ë¦¬ ì™„ë£Œìœ¨ì´ ${processingRate}%ë¡œ ìš°ìˆ˜í•©ë‹ˆë‹¤. í˜„ì¬ í”„ë¡œì„¸ìŠ¤ë¥¼ ìœ ì§€í•˜ì„¸ìš”.`
                });
            }

            // Analyze keyword diversity
            const keywordCount = Object.keys(wordFrequency).length;
            if (keywordCount > 20) {
                insights.push({
                    icon: 'ğŸ”„',
                    title: 'ì´ìŠˆ ë‹¤ì–‘ì„±',
                    content: `${keywordCount}ê°œì˜ ë‹¤ì–‘í•œ í‚¤ì›Œë“œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì–‘í•œ ì´ìŠˆì— ëŒ€í•œ ì¢…í•©ì ì¸ ëŒ€ì‘ ë°©ì•ˆì´ í•„ìš”í•©ë‹ˆë‹¤.`
                });
            }

            if (insights.length === 0) {
                insightsDiv.innerHTML = '<div class="text-center text-blue-600">ë¶„ì„í•  ë°ì´í„°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>';
                return;
            }

            insightsDiv.innerHTML = insights.map(insight => `
                <div class="flex items-start space-x-3 p-4 bg-white rounded-lg border border-blue-100">
                    <div class="flex-shrink-0 text-2xl">${insight.icon}</div>
                    <div class="flex-1">
                        <h4 class="font-medium text-blue-900">${insight.title}</h4>
                        <p class="text-sm text-blue-700 mt-1">${insight.content}</p>
                    </div>
                </div>
            `).join('');
        }

        function updateChannelChart(data) {
            if (typeof Chart === 'undefined') {
                console.error('âŒ Chart.js not available for channel chart');
                return;
            }

            const channelCounts = {};
            data.forEach(item => {
                channelCounts[item.channel] = (channelCounts[item.channel] || 0) + 1;
            });

            const ctx = document.getElementById('channelChart').getContext('2d');
            
            if (charts.channel) {
                charts.channel.destroy();
            }
            
            charts.channel = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(channelCounts).map(channel => {
                        const labels = { sms: 'SMS', email: 'ì´ë©”ì¼', web: 'ì›¹í¼', call: 'í†µí™”' };
                        return labels[channel] || channel;
                    }),
                    datasets: [{
                        data: Object.values(channelCounts),
                        backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }

        function updateStatusChart(data) {
            if (typeof Chart === 'undefined') {
                console.error('âŒ Chart.js not available for status chart');
                return;
            }

            const statusCounts = {};
            data.forEach(item => {
                statusCounts[item.status] = (statusCounts[item.status] || 0) + 1;
            });

            const ctx = document.getElementById('statusChart').getContext('2d');
            
            if (charts.status) {
                charts.status.destroy();
            }
            
            charts.status = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(statusCounts).map(status => {
                        const labels = { pending: 'ëŒ€ê¸°ì¤‘', classified: 'ë¶„ë¥˜ì™„ë£Œ', assigned: 'í• ë‹¹ë¨', processed: 'ì²˜ë¦¬ì™„ë£Œ' };
                        return labels[status] || status;
                    }),
                    datasets: [{
                        label: 'ê±´ìˆ˜',
                        data: Object.values(statusCounts),
                        backgroundColor: '#6366F1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updatePriorityChart(data) {
            if (typeof Chart === 'undefined') {
                console.error('âŒ Chart.js not available for priority chart');
                return;
            }

            const priorityCounts = {};
            data.forEach(item => {
                priorityCounts[item.priority] = (priorityCounts[item.priority] || 0) + 1;
            });

            const ctx = document.getElementById('priorityChart').getContext('2d');
            
            if (charts.priority) {
                charts.priority.destroy();
            }
            
            charts.priority = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(priorityCounts).map(priority => {
                        const labels = { urgent: 'ê¸´ê¸‰', high: 'ë†’ìŒ', medium: 'ë³´í†µ', low: 'ë‚®ìŒ' };
                        return labels[priority] || priority;
                    }),
                    datasets: [{
                        data: Object.values(priorityCounts),
                        backgroundColor: ['#DC2626', '#F59E0B', '#10B981', '#6B7280']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }

        function updateTrendChart(data) {
            console.log('ğŸ“ˆ updateTrendChart called with', data.length, 'messages');
            if (typeof Chart === 'undefined') {
                console.error('âŒ Chart.js not available for trend chart');
                // Fall back to HTML chart
                updateFallbackTrendChart(data);
                return;
            }

            // Try to find canvas, if not found, use fallback
            const canvas = document.getElementById('trendChart');
            if (!canvas) {
                console.log('ğŸ“ˆ Canvas not found, using fallback chart');
                updateFallbackTrendChart(data);
                return;
            }

            // Group data by date
            const dailyCounts = {};
            data.forEach(item => {
                const date = new Date(item.createdAt).toISOString().split('T')[0];
                dailyCounts[date] = (dailyCounts[date] || 0) + 1;
            });

            console.log('ğŸ“ˆ Chart.js Daily counts:', dailyCounts);
            
            // Use the actual date range from the filtered data
            const dataDate = Object.keys(dailyCounts).sort();
            console.log('ğŸ“ˆ Chart.js Data dates found:', dataDate);
            let sortedDates;
            
            if (dataDate.length === 0) {
                // No data - show empty chart
                sortedDates = [];
            } else if (dataDate.length === 1) {
                // Single day - show that day plus 6 days around it for context
                const singleDate = new Date(dataDate[0]);
                sortedDates = [];
                for (let i = -3; i <= 3; i++) {
                    const date = new Date(singleDate);
                    date.setDate(date.getDate() + i);
                    const dateStr = date.toISOString().split('T')[0];
                    sortedDates.push(dateStr);
                }
            } else {
                // Multiple days - use the actual range from data
                const startDate = new Date(dataDate[0]);
                const endDate = new Date(dataDate[dataDate.length - 1]);
                sortedDates = [];
                
                const currentDate = new Date(startDate);
                while (currentDate <= endDate) {
                    sortedDates.push(currentDate.toISOString().split('T')[0]);
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            }
            
            const counts = sortedDates.map(date => dailyCounts[date] || 0);

            const ctx = canvas.getContext('2d');
            
            if (charts.trend) {
                charts.trend.destroy();
            }
            
            charts.trend = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sortedDates.map(date => new Date(date).toLocaleDateString('ko-KR')),
                    datasets: [{
                        label: 'ì¼ë³„ ì ‘ìˆ˜',
                        data: counts,
                        borderColor: '#8B5CF6',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function updateDataTable(data) {
            const tableBody = document.getElementById('dataTable');
            
            if (data.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="6" class="px-6 py-4 text-center text-gray-500">
                            í•„í„° ì¡°ê±´ì— ë§ëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
                        </td>
                    </tr>
                `;
                return;
            }

            const channelEmojis = { sms: 'ğŸ“±', email: 'ğŸ“§', web: 'ğŸŒ', call: 'ğŸ“' };
            const priorityColors = {
                urgent: 'bg-red-100 text-red-800',
                high: 'bg-orange-100 text-orange-800',
                medium: 'bg-yellow-100 text-yellow-800',
                low: 'bg-green-100 text-green-800'
            };
            const statusColors = {
                pending: 'bg-gray-100 text-gray-800',
                classified: 'bg-blue-100 text-blue-800',
                assigned: 'bg-purple-100 text-purple-800',
                processed: 'bg-green-100 text-green-800'
            };
            const statusLabels = {
                pending: 'ëŒ€ê¸°ì¤‘',
                classified: 'ë¶„ë¥˜ì™„ë£Œ',
                assigned: 'í• ë‹¹ë¨',
                processed: 'ì²˜ë¦¬ì™„ë£Œ'
            };

            tableBody.innerHTML = data.map(item => `
                <tr class="hover:bg-gray-50">
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        ${new Date(item.createdAt).toLocaleString('ko-KR')}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        ${channelEmojis[item.channel] || 'ğŸ“'} ${item.channel.toUpperCase()}
                    </td>
                    <td class="px-6 py-4 text-sm text-gray-900 max-w-xs truncate">
                        ${item.maskedContent || item.content}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${priorityColors[item.priority] || 'bg-gray-100 text-gray-800'}">
                            ${item.priority}
                        </span>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${statusColors[item.status] || 'bg-gray-100 text-gray-800'}">
                            ${statusLabels[item.status] || item.status}
                        </span>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        ${item.classification || '-'}
                    </td>
                </tr>
            `).join('');
        }

        // Event listeners
        document.getElementById('loadData').addEventListener('click', () => {
            console.log('ğŸ”„ Manual data load requested');
            loadReportData();
        });
        
        document.getElementById('applyFilters').addEventListener('click', loadReportData);
        
        document.getElementById('resetFilters').addEventListener('click', () => {
            document.getElementById('channelFilter').value = '';
            document.getElementById('statusFilter').value = '';
            document.getElementById('priorityFilter').value = '';
            
            const today = new Date();
            const lastWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            document.getElementById('startDate').value = lastWeek.toISOString().split('T')[0];
            document.getElementById('endDate').value = today.toISOString().split('T')[0];
            
            loadReportData();
        });

        document.getElementById('exportCSV').addEventListener('click', () => {
            const filters = getFilterValues();
            const filteredData = applyFilters(currentData, filters);
            exportToCSV(filteredData);
        });

        document.getElementById('testWordCloud').addEventListener('click', () => {
            console.log('ğŸ§ª Testing word cloud with current data:', currentData.length, 'messages');
            if (currentData.length > 0) {
                updateWordCloud(currentData);
            } else {
                console.log('ğŸ“ No data loaded, using sample Korean apartment terms for testing');
                // Use sample Korean apartment management terms for testing
                const sampleData = [
                    { content: 'ì—˜ë¦¬ë² ì´í„° ê³ ì¥ ì‹ ê³ í•©ë‹ˆë‹¤', classification: { keywords: ['ì—˜ë¦¬ë² ì´í„°', 'ê³ ì¥', 'ì‹ ê³ '] } },
                    { content: 'ì£¼ì°¨ì¥ ë¶ˆë²•ì£¼ì°¨ ë¬¸ì œ', classification: { keywords: ['ì£¼ì°¨ì¥', 'ë¶ˆë²•ì£¼ì°¨', 'ë¬¸ì œ'] } },
                    { content: 'ì†ŒìŒ ë¯¼ì› ì ‘ìˆ˜', classification: { keywords: ['ì†ŒìŒ', 'ë¯¼ì›', 'ì ‘ìˆ˜'] } },
                    { content: 'ëˆ„ìˆ˜ ì‹ ê³  ë“œë¦½ë‹ˆë‹¤', classification: { keywords: ['ëˆ„ìˆ˜', 'ì‹ ê³ ', 'ìˆ˜ë¦¬'] } },
                    { content: 'ê´€ë¦¬ë¹„ ë¬¸ì˜ì‚¬í•­', classification: { keywords: ['ê´€ë¦¬ë¹„', 'ë¬¸ì˜', 'ìš”ê¸ˆ'] } },
                    { content: 'íƒë°°ë³´ê´€í•¨ ê³ ì¥', classification: { keywords: ['íƒë°°ë³´ê´€í•¨', 'ê³ ì¥', 'ìˆ˜ë¦¬'] } },
                    { content: 'ë‚œë°© ì˜¨ë„ ì¡°ì ˆ ìš”ì²­', classification: { keywords: ['ë‚œë°©', 'ì˜¨ë„', 'ì¡°ì ˆ'] } },
                    { content: 'ì²­ì†Œ ìƒíƒœ ë¶ˆë§Œ', classification: { keywords: ['ì²­ì†Œ', 'ìƒíƒœ', 'ë¶ˆë§Œ'] } },
                    { content: 'ë³´ì•ˆ ë¬¸ì œ ì‹ ê³ ', classification: { keywords: ['ë³´ì•ˆ', 'ë¬¸ì œ', 'ì‹ ê³ '] } },
                    { content: 'ì‹œì„¤ ê°œì„  ê±´ì˜', classification: { keywords: ['ì‹œì„¤', 'ê°œì„ ', 'ê±´ì˜'] } }
                ];
                updateWordCloud(sampleData);
                alert('ìƒ˜í”Œ ë°ì´í„°ë¡œ ì›Œë“œí´ë¼ìš°ë“œë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤. ì‹¤ì œ ë°ì´í„°ë¥¼ ë³´ë ¤ë©´ ë¨¼ì € "ğŸ“Š ë°ì´í„° ë¡œë“œ" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.');
            }
        });

        document.getElementById('debugLibraries').addEventListener('click', () => {
            const chartAvailable = typeof Chart !== 'undefined';
            const wordCloudAvailable = typeof WordCloud !== 'undefined';
            
            alert(`ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒíƒœ:
Chart.js: ${chartAvailable ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì‹¤íŒ¨'}
WordCloud: ${wordCloudAvailable ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì‹¤íŒ¨'}
ë°ì´í„°: ${currentData.length}ê°œ ë©”ì‹œì§€`);
            
            console.log('ğŸ” Library debug info:', {
                Chart: typeof Chart,
                WordCloud: typeof WordCloud,
                dataCount: currentData.length
            });
        });

        document.getElementById('testKeywords').addEventListener('click', () => {
            console.log('ğŸ” Testing keyword extraction...');
            
            // Test with sample text
            const testText = "ê´€ë¦¬ë¹„ ì˜ìˆ˜ì¦ ì¬ë°œê¸‰ ë°›ì„ ìˆ˜ ìˆë‚˜ìš”? ì—˜ë¦¬ë² ì´í„°ê°€ ê³ ì¥ë‚¬ì–´ìš”. ì£¼ì°¨ì¥ ì†ŒìŒì´ ì‹¬í•´ìš”.";
            const keywords = extractKoreanKeywords(testText);
            console.log('ğŸ” Extracted keywords from test text:', keywords);
            
            // Test with current data if available
            if (currentData.length > 0) {
                const sampleMessage = currentData[0];
                const sampleKeywords = extractKoreanKeywords(sampleMessage.content);
                console.log('ğŸ” Sample message:', sampleMessage.content);
                console.log('ğŸ” Extracted keywords:', sampleKeywords);
                
                // Test the update functions with sample data
                const testFrequency = { 'ê´€ë¦¬ë¹„': 5, 'ì—˜ë¦¬ë² ì´í„°': 3, 'ì£¼ì°¨ì¥': 4, 'ì†ŒìŒ': 2, 'ê³ ì¥': 3 };
                console.log('ğŸ” Testing updateTopKeywords with sample data');
                updateTopKeywords(testFrequency);
                
                console.log('ğŸ” Testing updateCategoryKeywords with sample data');
                updateCategoryKeywords(testFrequency);
            }
            
            alert('í‚¤ì›Œë“œ ì¶”ì¶œ í…ŒìŠ¤íŠ¸ ì™„ë£Œ. ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
        });

        document.getElementById('testSections').addEventListener('click', () => {
            console.log('ğŸ§ª Testing all sections with sample data...');
            
            // Test data
            const testData = [
                { createdAt: '2025-09-20T10:00:00Z', content: 'ì—˜ë¦¬ë² ì´í„°ê°€ ê³ ì¥ë‚¬ì–´ìš”', classification: 'maintenance' },
                { createdAt: '2025-09-20T11:00:00Z', content: 'ì£¼ì°¨ì¥ ì†ŒìŒì´ ì‹¬í•´ìš”', classification: 'noise' },
                { createdAt: '2025-09-20T12:00:00Z', content: 'ê´€ë¦¬ë¹„ ë¬¸ì˜ë“œë¦½ë‹ˆë‹¤', classification: 'billing' },
                { createdAt: '2025-09-19T14:00:00Z', content: 'ìˆ˜ë¦¬ ìš”ì²­í•©ë‹ˆë‹¤', classification: 'maintenance' },
                { createdAt: '2025-09-18T16:00:00Z', content: 'ë³´ì•ˆ ë¬¸ì œ ì‹ ê³ ', classification: 'security' }
            ];
            
            const testFrequency = { 
                'ì—˜ë¦¬ë² ì´í„°': 5, 'ê³ ì¥': 4, 'ì£¼ì°¨ì¥': 3, 'ì†ŒìŒ': 3, 'ê´€ë¦¬ë¹„': 2, 
                'ìˆ˜ë¦¬': 4, 'ë³´ì•ˆ': 2, 'ë¬¸ì œ': 3, 'ì‹ ê³ ': 2 
            };
            
            console.log('ğŸ§ª Testing updateTopKeywords...');
            updateTopKeywords(testFrequency);
            
            console.log('ğŸ§ª Testing updateCategoryKeywords...');
            updateCategoryKeywords(testFrequency);
            
            console.log('ğŸ§ª Testing updateFallbackTrendChart...');
            updateFallbackTrendChart(testData);
            
            alert('ì„¹ì…˜ í…ŒìŠ¤íŠ¸ ì™„ë£Œ! ìƒìœ„ í‚¤ì›Œë“œ, ì¹´í…Œê³ ë¦¬ë³„ í‚¤ì›Œë“œ, ì¼ë³„ ì¶”ì´ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.');
        });

        document.getElementById('simpleTest').addEventListener('click', () => {
            console.log('âœ… Running simple HTML update test...');
            
            // Test 1: Update top keywords directly
            const topKeywordsDiv = document.getElementById('topKeywords');
            if (topKeywordsDiv) {
                topKeywordsDiv.innerHTML = `
                    <div class="flex items-center justify-between p-3 border rounded-lg">
                        <div class="flex items-center space-x-3">
                            <div class="w-8 h-8 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center text-sm font-bold">1</div>
                            <div>
                                <div class="font-medium text-gray-900">ì—˜ë¦¬ë² ì´í„°</div>
                                <div class="text-sm text-gray-500">5íšŒ ì–¸ê¸‰</div>
                            </div>
                        </div>
                        <div class="w-20 bg-gray-200 rounded-full h-2">
                            <div class="bg-indigo-500 h-2 rounded-full" style="width: 100%"></div>
                        </div>
                    </div>
                `;
                console.log('âœ… Top keywords updated');
            } else {
                console.error('âŒ topKeywords element not found');
            }
            
            // Test 2: Update category keywords directly
            const categoryKeywordsDiv = document.getElementById('categoryKeywords');
            if (categoryKeywordsDiv) {
                categoryKeywordsDiv.innerHTML = `
                    <div class="border rounded-lg p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-medium text-gray-900">ì‹œì„¤ê´€ë¦¬</h4>
                            <span class="text-sm text-gray-500">5íšŒ</span>
                        </div>
                        <div class="mb-3">
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div class="bg-blue-500 h-2 rounded-full" style="width: 100%"></div>
                            </div>
                        </div>
                        <div class="flex flex-wrap gap-2">
                            <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                                ì—˜ë¦¬ë² ì´í„° (5)
                            </span>
                        </div>
                    </div>
                `;
                console.log('âœ… Category keywords updated');
            } else {
                console.error('âŒ categoryKeywords element not found');
            }
            
            // Test 3: Update trend chart directly
            const trendChart = document.getElementById('trendChart');
            if (trendChart) {
                const container = trendChart.parentElement;
                container.innerHTML = `
                    <div class="space-y-2">
                        <div class="flex items-center justify-between">
                            <span class="text-sm font-medium">9ì›” 20ì¼</span>
                            <div class="flex items-center space-x-2">
                                <div class="w-32 bg-gray-200 rounded-full h-2">
                                    <div class="bg-purple-500 h-2 rounded-full" style="width: 100%"></div>
                                </div>
                                <span class="text-sm text-gray-600">5ê±´</span>
                            </div>
                        </div>
                    </div>
                `;
                console.log('âœ… Trend chart updated');
            } else {
                console.error('âŒ trendChart element not found');
            }
            
            alert('ê°„ë‹¨ í…ŒìŠ¤íŠ¸ ì™„ë£Œ! ëª¨ë“  ì„¹ì…˜ì´ ì§ì ‘ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.');
        });

        document.getElementById('debugFilters').addEventListener('click', () => {
            console.log('ğŸ” Debugging filters and data flow...');
            
            // Check current filter values
            const filters = getFilterValues();
            console.log('ğŸ” Current filters:', filters);
            
            // Check current data
            console.log('ğŸ” Current data length:', currentData.length);
            console.log('ğŸ” Sample data:', currentData.slice(0, 3));
            
            // Apply filters manually
            const filteredData = applyFilters(currentData, filters);
            console.log('ğŸ” Filtered data length:', filteredData.length);
            console.log('ğŸ” Filtered sample:', filteredData.slice(0, 3));
            
            // Test keyword extraction
            if (filteredData.length > 0) {
                console.log('ğŸ” Testing keyword extraction on filtered data...');
                const keywordFrequency = {};
                
                filteredData.forEach(item => {
                    if (item.classification) {
                        const categoryNames = {
                            'billing': 'ê´€ë¦¬ë¹„',
                            'maintenance': 'ìˆ˜ë¦¬',
                            'parking': 'ì£¼ì°¨',
                            'noise': 'ì†ŒìŒ',
                            'inquiry': 'ë¬¸ì˜',
                            'complaint': 'ë¯¼ì›',
                            'facility': 'ì‹œì„¤',
                            'security': 'ë³´ì•ˆ'
                        };
                        const categoryKeyword = categoryNames[item.classification] || item.classification;
                        keywordFrequency[categoryKeyword] = (keywordFrequency[categoryKeyword] || 0) + 3;
                    }
                    
                    const content = item.content || item.maskedContent;
                    const keywords = extractKoreanKeywords(content);
                    keywords.forEach(keyword => {
                        keywordFrequency[keyword] = (keywordFrequency[keyword] || 0) + 1;
                    });
                });
                
                console.log('ğŸ” Extracted keyword frequency:', keywordFrequency);
                console.log('ğŸ” Total unique keywords:', Object.keys(keywordFrequency).length);
                
                // Test updating sections
                console.log('ğŸ” Testing section updates...');
                updateTopKeywords(keywordFrequency);
                updateCategoryKeywords(keywordFrequency);
                updateFallbackTrendChart(filteredData);
            }
            
            alert('í•„í„° ë””ë²„ê·¸ ì™„ë£Œ! ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
        });

        document.getElementById('debugFlow').addEventListener('click', () => {
            console.log('ğŸš¨ === COMPREHENSIVE DEBUG START ===');
            
            // Step 1: Check if data exists
            console.log('ğŸ“Š Step 1: Data Check');
            console.log('Current data length:', currentData.length);
            if (currentData.length > 0) {
                console.log('Sample data:', currentData[0]);
            }
            
            // Step 2: Test filters
            console.log('ğŸ“Š Step 2: Filter Test');
            const filters = getFilterValues();
            console.log('Current filters:', filters);
            const filteredData = applyFilters(currentData, filters);
            console.log('Filtered data length:', filteredData.length);
            
            // Step 3: Test each chart function individually
            console.log('ğŸ“Š Step 3: Chart Functions Test');
            
            // Test trend chart specifically
            console.log('Testing updateFallbackTrendChart...');
            try {
                updateFallbackTrendChart(filteredData);
                console.log('âœ… updateFallbackTrendChart completed');
            } catch (error) {
                console.error('âŒ updateFallbackTrendChart failed:', error);
            }
            
            // Test Chart.js version if available
            if (typeof Chart !== 'undefined') {
                console.log('Testing updateTrendChart (Chart.js)...');
                try {
                    updateTrendChart(filteredData);
                    console.log('âœ… updateTrendChart completed');
                } catch (error) {
                    console.error('âŒ updateTrendChart failed:', error);
                }
            }
            
            // Step 4: Test keyword functions
            console.log('ğŸ“Š Step 4: Keyword Functions Test');
            
            // Extract keywords manually
            const keywordFrequency = {};
            filteredData.forEach(item => {
                if (item.classification) {
                    const categoryNames = {
                        'billing': 'ê´€ë¦¬ë¹„', 'maintenance': 'ìˆ˜ë¦¬', 'parking': 'ì£¼ì°¨',
                        'noise': 'ì†ŒìŒ', 'inquiry': 'ë¬¸ì˜', 'complaint': 'ë¯¼ì›',
                        'facility': 'ì‹œì„¤', 'security': 'ë³´ì•ˆ'
                    };
                    const categoryKeyword = categoryNames[item.classification] || item.classification;
                    keywordFrequency[categoryKeyword] = (keywordFrequency[categoryKeyword] || 0) + 3;
                }
                
                const content = item.content || item.maskedContent;
                const keywords = extractKoreanKeywords(content);
                keywords.forEach(keyword => {
                    keywordFrequency[keyword] = (keywordFrequency[keyword] || 0) + 1;
                });
            });
            
            console.log('Extracted keywords:', Object.keys(keywordFrequency).length);
            console.log('Sample keywords:', Object.entries(keywordFrequency).slice(0, 5));
            
            // Test keyword functions
            try {
                updateTopKeywords(keywordFrequency);
                console.log('âœ… updateTopKeywords completed');
            } catch (error) {
                console.error('âŒ updateTopKeywords failed:', error);
            }
            
            try {
                updateCategoryKeywords(keywordFrequency);
                console.log('âœ… updateCategoryKeywords completed');
            } catch (error) {
                console.error('âŒ updateCategoryKeywords failed:', error);
            }
            
            // Step 5: Check DOM elements
            console.log('ğŸ“Š Step 5: DOM Elements Check');
            
            // Check trend chart section
            const trendSection = Array.from(document.querySelectorAll('h3')).find(h3 => 
                h3.textContent.includes('ì¼ë³„ ì ‘ìˆ˜ ì¶”ì´')
            );
            if (trendSection) {
                const trendContainer = trendSection.parentElement.nextElementSibling;
                if (trendContainer) {
                    console.log('âœ… trendChart section and container found');
                } else {
                    console.error('âŒ trendChart container NOT found');
                }
            } else {
                console.error('âŒ trendChart section NOT found');
            }
            
            // Check other elements
            const elements = {
                'topKeywords': document.getElementById('topKeywords'),
                'categoryKeywords': document.getElementById('categoryKeywords')
            };
            
            Object.entries(elements).forEach(([name, element]) => {
                if (element) {
                    console.log(`âœ… ${name} element found`);
                } else {
                    console.error(`âŒ ${name} element NOT found`);
                }
            });
            
            console.log('ğŸš¨ === COMPREHENSIVE DEBUG END ===');
            alert('ì „ì²´ ë””ë²„ê·¸ ì™„ë£Œ! ì½˜ì†”ì„ í™•ì¸í•˜ì„¸ìš”.');
        });

        document.getElementById('fixTrendChart').addEventListener('click', () => {
            console.log('ğŸ”§ Forcing trend chart fix...');
            
            // Find the trend chart section by looking for the title
            const trendSection = Array.from(document.querySelectorAll('h3')).find(h3 => 
                h3.textContent.includes('ì¼ë³„ ì ‘ìˆ˜ ì¶”ì´')
            );
            
            if (!trendSection) {
                console.error('âŒ Could not find trend chart section');
                alert('âŒ ì¼ë³„ ì ‘ìˆ˜ ì¶”ì´ ì„¹ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            
            // Find the container (should be the parent's next sibling with class p-6)
            const container = trendSection.parentElement.nextElementSibling;
            console.log('Found container:', container);
            
            if (!container) {
                console.error('âŒ No container found');
                alert('âŒ Container not found');
                return;
            }
            
            // Clear everything and create a simple chart
            console.log('ğŸ”§ Clearing container and creating simple chart...');
            
            // Remove all existing content
            container.innerHTML = '';
            
            // Create the chart directly with inline styles for guaranteed visibility
            const chartHTML = `
                <div style="padding: 20px;">
                    <div style="text-align: center; color: #6B7280; font-size: 12px; margin-bottom: 15px;">ì¼ë³„ ì ‘ìˆ˜ í˜„í™© (ê°•ì œ ìˆ˜ì •ë¨)</div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <span style="font-size: 14px; font-weight: 500; color: #374151; width: 80px;">9ì›” 17ì¼</span>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="width: 120px; height: 12px; background-color: #E5E7EB; border-radius: 6px; overflow: hidden;">
                                <div style="width: 0%; height: 100%; background-color: #8B5CF6; border-radius: 6px;"></div>
                            </div>
                            <span style="font-size: 13px; color: #6B7280; width: 40px; text-align: right;">0ê±´</span>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <span style="font-size: 14px; font-weight: 500; color: #374151; width: 80px;">9ì›” 18ì¼</span>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="width: 120px; height: 12px; background-color: #E5E7EB; border-radius: 6px; overflow: hidden;">
                                <div style="width: 0%; height: 100%; background-color: #8B5CF6; border-radius: 6px;"></div>
                            </div>
                            <span style="font-size: 13px; color: #6B7280; width: 40px; text-align: right;">0ê±´</span>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <span style="font-size: 14px; font-weight: 500; color: #374151; width: 80px;">9ì›” 19ì¼</span>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="width: 120px; height: 12px; background-color: #E5E7EB; border-radius: 6px; overflow: hidden;">
                                <div style="width: 0%; height: 100%; background-color: #8B5CF6; border-radius: 6px;"></div>
                            </div>
                            <span style="font-size: 13px; color: #6B7280; width: 40px; text-align: right;">0ê±´</span>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0; background-color: #F3F4F6;">
                        <span style="font-size: 14px; font-weight: 600; color: #374151; width: 80px;">9ì›” 20ì¼</span>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="width: 120px; height: 12px; background-color: #E5E7EB; border-radius: 6px; overflow: hidden;">
                                <div style="width: 100%; height: 100%; background-color: #8B5CF6; border-radius: 6px; transition: width 0.3s ease;"></div>
                            </div>
                            <span style="font-size: 13px; color: #374151; font-weight: 600; width: 40px; text-align: right;">400ê±´</span>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <span style="font-size: 14px; font-weight: 500; color: #374151; width: 80px;">9ì›” 21ì¼</span>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="width: 120px; height: 12px; background-color: #E5E7EB; border-radius: 6px; overflow: hidden;">
                                <div style="width: 0%; height: 100%; background-color: #8B5CF6; border-radius: 6px;"></div>
                            </div>
                            <span style="font-size: 13px; color: #6B7280; width: 40px; text-align: right;">0ê±´</span>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = chartHTML;
            console.log('âœ… Chart forcefully created');
            alert('âœ… ì°¨íŠ¸ê°€ ê°•ì œë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!');
        });

        function exportToCSV(data) {
            const headers = ['ì ‘ìˆ˜ì¼ì‹œ', 'ì±„ë„', 'ë‚´ìš©', 'ìš°ì„ ìˆœìœ„', 'ìƒíƒœ', 'ë¶„ë¥˜'];
            const csvContent = [
                headers.join(','),
                ...data.map(item => [
                    new Date(item.createdAt).toLocaleString('ko-KR'),
                    item.channel,
                    `"${(item.maskedContent || item.content).replace(/"/g, '""')}"`,
                    item.priority,
                    item.status,
                    item.classification || ''
                ].join(','))
            ].join('\n');

            const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `ì ‘ìˆ˜í˜„í™©_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>